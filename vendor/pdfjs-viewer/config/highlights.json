[
  {
    "id": "highlight-1",
    "location": [
      25,
      505,
      256,
      407
    ],
    "page": 1,
    "text": "Enviro"
  },
  {
    "id": "highlight-2",
    "location": [
      25,
      359,
      276,
      261
    ],
    "page": 1,
    "text": "Report"
  },
  {
    "id": "highlight-99",
    "location": [
      22,
      500,
      563,
      267
    ],
    "page": 1,
    "text": "Environmental Progress Report"
  },
   {
    "id": "highlight-98",
    "location": [
      584,
      298,
      669,
      286
    ],
    "page": 4,
    "text": "Read more on page 15."
  },
  {
    "id": "highlight-4",
    "location": [
      46,
      441,
      265,
      411
    ],
    "page": 4,
    "text": "Reduced our overall GHG emissions by more than 60 percent"
  },
  {
    "id": "highlight-5",
    "location": [
      315,
      572,
      239,
      -53
    ],
    "page": 6,
    "text": "igure 5. A tree with two traces, a trunk trace and one branch\ntrace. The trunk trace contains a guard to which a branch trace was\nattached. The branch trace contain a guard that may fail and trigger\na side exit. Both the trunk and the branch trace loop back to the tree\nanchor, which is the beginning of the trace tree."
  },
  {
    "id": "highlight-6",
    "location": [
      54,
      432,
      501,
      -122
    ],
    "page": 11,
    "text": "Google’s V8 JS compiler. Our system generates particularly efﬁcient code for programs that beneﬁt most from\ntype specialization, which includes SunSpider Benchmark programs that perform bit manipulation. We type-specialize the code in question\nto use integer arithmetic, which substantially improves performance. For one of the benchmark programs we execute 25 times faster than\nthe SpiderMonkey interpreter, and almost 5 times faster than V8 and SFX. For a large number of benchmarks all three VMs produce similar\nresults. We perform worst on benchmark programs that we do not trace and instead fall back onto the interpreter. This includes the recursive\nbenchmarks access-binary-trees and control-flow-recursive, for which we currently don’t generate any native code.\nIn particular, the bitops benchmarks are short programs that per-\nform many bitwise operations, so TraceMonkey can cover the en-\ntire program with 1 or 2 traces that operate on integers. TraceMon-\nkey runs all the other programs in this set almost entirely as na"
  },
  {
    "id": "highlight-7",
    "location": [
      54,
      370,
      239,
      -43
    ],
    "page": 12,
    "text": "he total execution time in processor\nclock cycles by the number of bytecodes executed in the base\ninterpreter shows that on average, a bytecode executes in about\n35 cycles. Native traces take about 9 cycles per bytecode, a 3.9"
  },
  {
    "id": "highlight-8",
    "location": [
      315,
      504,
      239,
      -49
    ],
    "page": 13,
    "text": "onclusions\nThis paper described how to run dynamic languages efﬁciently by\nrecording hot traces and generating type-specialized native code.\nOur techniq"
  },
  {
    "id": "highlight-9",
    "location": [
      315,
      652,
      239,
      -43
    ],
    "page": 13,
    "text": "nline threading (15) copies chunks of interpreter native code which implement the required bytecodes into a native code cache,thus acting as a simple per-method JIT compiler that eliminates the dispatch overhead."
  }
]
